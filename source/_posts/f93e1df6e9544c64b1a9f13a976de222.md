---
layout: post
title: kotlin 协程 ,java 线程锁对比
abbrlink: f93e1df6e9544c64b1a9f13a976de222
tags:
  - 多线程
categories:
  - Mac笔记本
  - 多线程
date: 1744875654865
updated: 1744877386958
---

### kotlin Mutex

- 协程级别同步机制,用于挂起函数
- 基于非阻塞算法实现,使用CAS操作和协程挂起机制
- 不阻塞线程,只会挂起协程

```kotlin
private suspend fun lockSuspend(owner: Any? = null): Unit = suspendCancellableCoroutineReusable { cont ->
    // 创建一个包含当前协程continuation的等待节点
    val waiter = LockCont(owner, cont)
    
    while (true) { // 循环尝试将等待节点添加到队列
        val state = _state.value
        when (state) {
            is Empty -> { // 锁未被持有
                // 尝试直接获取锁
                if (_state.compareAndSet(state, Empty(owner))) {
                    cont.resume(Unit)
                    return@suspendCancellableCoroutineReusable
                }
            }
            is LockedQueue -> { // 锁被持有且有等待队列
                // 将当前协程添加到等待队列
                if (state.addLast(waiter)) {
                    // 设置取消处理程序
                    cont.invokeOnCancellation(nodeRemove(state, waiter))
                    return@suspendCancellableCoroutineReusable
                }
            }
            is Locked -> { // 锁被持有但没有等待队列
                // 创建新的等待队列
                val queue = LockedQueue(state.owner)
                queue.addLast(waiter)
                if (_state.compareAndSet(state, queue)) {
                    // 设置取消处理程序
                    cont.invokeOnCancellation(nodeRemove(queue, waiter))
                    return@suspendCancellableCoroutineReusable
                }
            }
        }
    }
}

```

`suspendCancellableCoroutineReusable` 是一个协程构建器，它会挂起当前协程，并在将来某个时刻通过调用 `cont.resume(Unit) `来恢复协程执行。

```css
协程调用 lock()
    │
    ├─ tryLock() 成功 ──→ 返回
    │
    ▼
lockSuspend()
    │
    ├─ 创建等待节点 (LockCont)
    │
    ▼
循环尝试获取锁或加入等待队列
    │
    ├─ 锁空闲 ──→ CAS 获取锁 ──→ 恢复协程执行
    │
    ├─ 锁被占用，无等待队列 ──→ 创建队列并加入
    │
    ├─ 锁被占用，有等待队列 ──→ 加入等待队列
    │
    ▼
协程挂起，等待被唤醒
    │
    ▼
锁持有者调用 unlock()
    │
    ▼
检查等待队列并唤醒第一个等待者
    │
    ▼
被唤醒的协程恢复执行

```

## 性能对比

五竞争条件下:`synchronized` 优于`lock`

### synchronized

- (偏向锁模式）：无需 CAS 操作，只需检查线程 ID
- 锁信息存储在对象头中，访问局部性好
- 在偏向锁模式下，获取锁的代码路径极短
- JIT 编译器优化
  - 锁消除
  - 锁粗化

### lock

- 即使无竞争，也需要至少一次 CAS 操作来获取锁
- 锁状态存储在独立的 AQS 对象中，可能导致额外的缓存未命中
- 即使是最简单的情况，也需要执行多个方法调用

```java
// ReentrantLock.lock() 的简化调用路径
public void lock() {
    sync.acquire(1); // 调用AQS的acquire方法
}

// AbstractQueuedSynchronizer.acquire()
public final void acquire(int arg) {
    if (!tryAcquire(arg) && 
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

// ReentrantLock中NonfairSync.tryAcquire()
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

// ReentrantLock.nonfairTryAcquire()
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState(); // volatile读
    if (c == 0) {
        if (compareAndSetState(0, acquires)) { // CAS操作
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        setState(nextc); // volatile写
        return true;
    }
    return false;
}

```

> 即使在最简单的无竞争情况下，ReentrantLock 也需要执行多个方法调用、一次 volatile 读、一次 CAS 操作和一次 volatile 写。

#### 使用建议

- 协程中使用Mutex
- 线程中无竞争或低竞争情况: 优先使用 `synchronized`
- 高级特性时,使用`ReentrantLock`

```java
	// 适合ReentrantLock的场景
private final Lock lock = new ReentrantLock();

public void processWith(long timeout) throws InterruptedException {
    if (lock.tryLock(timeout, TimeUnit.MILLISECONDS)) {
        try {
            // 需要超时特性的操作
        } finally {
            lock.unlock();
        }
    }
}

```

- 复杂并发控制

```java
// 需要多个条件变量
private final ReentrantLock lock = new ReentrantLock();
private final Condition notFull = lock.newCondition();
private final Condition notEmpty = lock.newCondition();
```
