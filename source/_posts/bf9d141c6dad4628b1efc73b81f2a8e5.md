---
layout: post
title: Activity启动
abbrlink: bf9d141c6dad4628b1efc73b81f2a8e5
tags:
  - framework
categories:
  - framework
  - window
date: 1756969402001
updated: 1757041547974
---

![ec8d045c406bb79942cb2cf0cf7c130c.png](/resources/8d2ceb6a54ed4bbdbae1878e2f71da64.png)

### 桌面点击 相机图标然后返回键退出到桌面

![e4c00459647e23e47a04ed7c2b9ecb67.png](/resources/46622a80323b4920b5b84e92858e20a4.png)

![0024bdad7b9808c77b81861aec0951d2.png](/resources/5eb42425996e47838994dfaf62c37784.png)

### Task 添加

> `class Task extends WindowContainer<WindowContainer>`

![2603b945e89705f32c4166c53a38c050.png](/resources/06370a344a3c45598ac7419a22066d62.png)

### ActivityRecord添加

> `final class ActivityRecord extends WindowToken`\
> `class WindowToken extends WindowContainer<WindowState>`

```java
ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller,
            int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage,
            @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType,
            ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,
            String _resultWho, int _reqCode, boolean _componentSpecified,
            boolean _rootVoiceInteraction, ActivityStackSupervisor supervisor,
            ActivityOptions options, ActivityRecord sourceRecord) {
        super(_service.mWindowManager, new Token(_intent).asBinder(), TYPE_APPLICATION, true,
                null /* displayContent */, false /* ownerCanManageAppTokens */);
...

```

![11e3dcc5aecf74e9ad453219e15685d6.png](/resources/b190f0c368f84d6eaf0c26f854dff092.png)

### token添加

![bc07ddd65ad9e8113f17fe2177bf858a.png](/resources/715739cc90d94c8382551185038c608f.png)

```java
static class Token extends IApplicationToken.Stub {
        private WeakReference<ActivityRecord> weakActivity;
        private final String name;
        private final String tokenString;

        Token(Intent intent) {
            name = intent.getComponent().flattenToShortString();
            tokenString = "Token{" + Integer.toHexString(System.identityHashCode(this)) + "}";
        }
}
```

### pause前一个 task

![e8345d0e8513a7d054e92dad3d3ec016.png](/resources/208fe067568340d1a6cb3dc606930771.png)

### realStartActivityLocked

![5eba95b3144f1aaee0a7df679eab30da.png](/resources/49db3d1874e54c62b64391e1fe9a6b49.png)

### 执行顺序

```java
//ActivityStarter.java
int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, Task inTask,
            boolean restrictedBgActivity, NeededUriGrants intentGrants) {
    //计算 task
    final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask();
    //首次添加 newTask = true
    final boolean newTask = targetTask == null;
    ...
    if (mTargetStack == null) {
        //挂载 Task 节点 到 DefaultTaskDisplayArea
        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);
    }
    if (newTask) {
        final Task taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTask() : null;
        //挂载 activityRecord 到 上面的 Task 节点
        //
        setNewTask(taskToAffiliate);
        if (mService.getLockTaskController().isLockTaskModeViolation(
                mStartActivity.getTask())) {
            Slog.e(TAG, "Attempted Lock Task Mode violation mStartActivity=" + mStartActivity);
            return START_RETURN_LOCK_TASK_MODE_VIOLATION;
        }
    } else if (mAddingToTask) {
        addOrReparentStartingActivity(targetTask, "adding to task");
    }
    ...
    //task 切换动画 wms 侧
    mTargetStack.startActivityLocked(mStartActivity,
                topStack != null ? topStack.getTopNonFinishingActivity() : null, newTask,
                mKeepCurTransition, mOptions);
    ...
    //start Process
    mRootWindowContainer.resumeFocusedStacksTopActivities(
                        mTargetStack, mStartActivity, mOptions);
    ...
}
....



// 目标进程启动完成
- ams.attachApplication -> ams.attachApplicationLocked
	-> ATMS.attachApplication
		-> mRootWindowContainer.attachApplication 
		> 1. 遍历 每个display(一般只有一个display,但显示屏时)下的 TaskDisplayArea
		> 2. 根据uid, 状态name processName 等过滤目标进程的 ActivityRecord
		> 3. 符合条件的调用 `realStartActivityLocked`
	
//相关代码:
//mRootWindowContainer.attachApplication
boolean attachApplication(WindowProcessController app) throws RemoteException {
    boolean didSomething = false;
    for (int displayNdx = getChildCount() - 1; displayNdx >= 0; --displayNdx) {
        mTmpRemoteException = null;
        mTmpBoolean = false; // Set to true if an activity was started.

        final DisplayContent display = getChildAt(displayNdx);
        for (int areaNdx = display.getTaskDisplayAreaCount() - 1; areaNdx >= 0; --areaNdx) {
            final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx);
            for (int taskNdx = taskDisplayArea.getStackCount() - 1; taskNdx >= 0; --taskNdx) {
                final ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx);
                if (rootTask.getVisibility(null /*starting*/) == STACK_VISIBILITY_INVISIBLE) {
                    break;
                }
                final PooledFunction c = PooledLambda.obtainFunction(
                        RootWindowContainer::startActivityForAttachedApplicationIfNeeded, this,
                        PooledLambda.__(ActivityRecord.class), app,
                        rootTask.topRunningActivity());
                rootTask.forAllActivities(c);
                c.recycle();
                if (mTmpRemoteException != null) {
                    throw mTmpRemoteException;
                }
            }
        }
        didSomething |= mTmpBoolean;
    }
    if (!didSomething) {
        ensureActivitiesVisible(null, 0, false /* preserve_windows */);
    }
    return didSomething;
}
private boolean startActivityForAttachedApplicationIfNeeded(ActivityRecord r,
        WindowProcessController app, ActivityRecord top) {
    if (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != null
            || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) {
        return false;
    }

    try {
        if (mStackSupervisor.realStartActivityLocked(r, app,
                top == r && r.isFocusable() /*andResume*/, true /*checkConfig*/)) {
            mTmpBoolean = true;
        }
    } catch (RemoteException e) {
        Slog.w(TAG, "Exception in new application when starting activity "
                + top.intent.getComponent().flattenToShortString(), e);
        mTmpRemoteException = e;
        return true;
    }
    return false;
}
```

### 关键时序图

```mermaid
sequenceDiagram
  autonumber
  actor Caller as 调用方进程\n(源Activity)
  participant ATMS as system_server\nATMS/ActivityStarter
  participant Zygote as Zygote/ProcessList
  participant App as 目标应用进程\n(ActivityThread)
  participant Act as Activity实例
  participant WMG as WindowManagerGlobal
  participant WMS as WMS

  Caller->>ATMS: startActivity(Intent)
  ATMS->>ATMS: ActivityStarter 解析Intent/Flag
  ATMS->>ATMS: 创建 ActivityRecord\n(生成 activity token: IBinder)
  note right of ATMS: token = ActivityRecord.appToken

  alt 目标进程未启动
    ATMS->>Zygote: startProcessLocked()
    Zygote-->>ATMS: 进程创建回调
    ATMS->>App: attachApplicationLocked()
  else 目标进程已存在
    ATMS->>ATMS: 直接复用现有进程
  end

  ATMS->>ATMS: realStartActivityLocked(r)
  ATMS-->>App: scheduleTransaction(LaunchActivityItem{token,...})

  App->>App: H(EXECUTE_TRANSACTION)
  App->>App: LaunchActivityItem.execute()
  App->>App: 创建 ActivityClientRecord(r')\n r'.token = token
  App->>App: mActivities.put(token, r')

  App->>App: performLaunchActivity(r')
  App->>Act: 反射 new Activity()
  App->>Act: Activity.attach(..., token)
  note right of Act: mToken = token\n创建 PhoneWindow\nsetWindowManager(带 token)

  App->>Act: callActivityOnCreate → onCreate()
  App->>Act: callActivityOnStart → onStart()

  App->>App: handleResumeActivity(token)
  App->>Act: performResumeActivity → onResume()

  App->>Act: makeVisible()
  Act->>WMG: WindowManagerGlobal.addView(decorView, lp[token])
  WMG-->>WMS: addWindow(decorView, token)

  WMS->>WMS: 查 token → 找到 ActivityRecord
  WMS->>WMS: 校验/层级/动画/焦点
  WMS-->>WMG: 窗口加入成功
  WMG-->>Act: ViewRootImpl 建立 & 请求绘制
  Act-->>Caller: 首帧呈现(用户可见)
  
  note over App,WMS: 后续生命周期事件用同一 token\nPause/Stop/Destroy 时按 token 查表
```
