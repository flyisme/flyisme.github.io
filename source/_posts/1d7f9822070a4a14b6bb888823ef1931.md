---
layout: post
title: Kotlin 实现单例的几种常见方式
abbrlink: 1d7f9822070a4a14b6bb888823ef1931
tags:
  - kotlin
categories:
  - Mac笔记本
  - kotlin
date: 1719212500952
updated: 1746519815343
---

## 饿汉式

```kotlin
object StateManagementHelper {

    fun init() {
        //do some initialization works

    }
}
```

## 懒汉式

```kotlin
class StateManagementHelper private constructor(){
    
    companion object {
        private var instance: StateManagementHelper? = null 
            @Synchronized get() {
            if (field == null)
                field = StateManagementHelper()
            return field
        }
    }

    fun init() {
        //do some initialization works
        
    }
}
```

## 双重检测(by lazy)

```kotlin
class StateManagementHelper private constructor(){

    companion object {
        val instance: StateManagementHelper 
                by lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) { StateManagementHelper() }
    }

    fun init() {
        //do some initialization works

    }
}
```

### dagger.internal.DoubleCheck (google 库)

```java
public final class DoubleCheck<T> implements Provider<T>, Lazy<T> {
  private static final Object UNINITIALIZED = new Object();

  private volatile Provider<T> provider;
  private volatile Object instance = UNINITIALIZED;

  private DoubleCheck(Provider<T> provider) {
    assert provider != null;
    this.provider = provider;
  }

  @SuppressWarnings("unchecked") // cast only happens when result comes from the provider
  @Override
  public T get() {
    Object result = instance;
    if (result == UNINITIALIZED) {
      synchronized (this) {
        result = instance;
        if (result == UNINITIALIZED) {
          result = provider.get();
		  // 解决 循环依赖可能有多个 实例的场景:A 依赖 B，B 依赖 A
          instance = reentrantCheck(instance, result);
          /* Null out the reference to the provider. We are never going to need it again, so we
           * can make it eligible for GC. */
          provider = null;
        }
      }
    }
    return (T) result;
  }

  /**
   * Checks to see if creating the new instance has resulted in a recursive call. If it has, and the
   * new instance is the same as the current instance, return the instance. However, if the new
   * instance differs from the current instance, an {@link IllegalStateException} is thrown.
   */
  public static Object reentrantCheck(Object currentInstance, Object newInstance) {
    boolean isReentrant = !(currentInstance == UNINITIALIZED
        // This check is needed for fastInit's implementation, which uses MemoizedSentinel types.
        || currentInstance instanceof MemoizedSentinel);

    if (isReentrant && currentInstance != newInstance) {
      throw new IllegalStateException("Scoped provider was invoked recursively returning "
          + "different results: " + currentInstance + " & " + newInstance + ". This is likely "
          + "due to a circular dependency.");
    }
    return newInstance;
  }

  /** Returns a {@link Provider} that caches the value from the given delegate provider. */
  // This method is declared this way instead of "<T> Provider<T> provider(Provider<T> delegate)"
  // to work around an Eclipse type inference bug: https://github.com/google/dagger/issues/949.
  public static <P extends Provider<T>, T> Provider<T> provider(P delegate) {
    checkNotNull(delegate);
    if (delegate instanceof DoubleCheck) {
      /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped
       * binding, we shouldn't cache the value again. */
      return delegate;
    }
    return new DoubleCheck<T>(delegate);
  }

  /** Returns a {@link Lazy} that caches the value from the given provider. */
  // This method is declared this way instead of "<T> Lazy<T> lazy(Provider<T> delegate)"
  // to work around an Eclipse type inference bug: https://github.com/google/dagger/issues/949.
  public static <P extends Provider<T>, T> Lazy<T> lazy(P provider) {
    if (provider instanceof Lazy) {
      @SuppressWarnings("unchecked")
      final Lazy<T> lazy = (Lazy<T>) provider;
      // Avoids memoizing a value that is already memoized.
      // NOTE: There is a pathological case where Provider<P> may implement Lazy<L>, but P and L
      // are different types using covariant return on get(). Right now this is used with
      // DoubleCheck<T> exclusively, which is implemented such that P and L are always
      // the same, so it will be fine for that case.
      return lazy;
    }
    return new DoubleCheck<T>(checkNotNull(provider));
  }
}
```

```java
public class Main {
    static DoubleCheck<A> aProvider;
    static DoubleCheck<B> bProvider;

    public static void main(String[] args) {
        // BrokenProvider 每次都 new 新对象
		// 假设:Thread 1
        aProvider = new DoubleCheck<>(new Provider<A>() {
            @Override
            public A get() {
                A a = new A();
                a.setB(bProvider.get());
                return a;
            }
        });
		// 假设:Thread 2
        bProvider = new DoubleCheck<>(new Provider<B>() {
            @Override
            public B get() {
                B b = new B();
                b.setA(aProvider.get());
                return b;
            }
        });

        try {
            aProvider.get();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

## 静态内部类

```kotlin
class StateManagementHelper private constructor(){

    companion object {
       val INSTANCE = StateHelperHolder.holder
    }
    
    private object StateHelperHolder {
        val holder = StateManagementHelper()
    }

    fun init() {
        //do some initialization works
        
    }
}
```

**类加载机制**：在Java中，类的加载和初始化是线程安全的。静态内部类 SingletonHolder 只有在第一次使用的时候才会被加载和初始化。由于类加载机制的保证，这个过程是线程安全的。
