---
layout: post
title: WindowManagerService
abbrlink: ab071aa0493f47848192051ecdb771eb
tags: []
categories:
  - framework
  - window
date: 1756710409825
updated: 1756776575565
---

## addWindow

调用栈 应用层 ViewRootImpl.setView ->Session.addToDisplayAsUser -> WMS.addWindow()

> `应用进程`\
> ![c6e8a845072fbaa768202712480fe176.png](/resources/665152dc59404b23a1cb37e8f8f08e57.png)\
> `system_process` wms\
> ![aed5a02c56a8827a6b40d556557bb294.png](/resources/1525d2b1c7844577814fd6bc73ad98c0.png)

```java

//从iWindow ibinder映射到服务器的窗口对象。
final HashMap<IBinder, WindowState> mWindowMap = new HashMap<>();
// app进程 IWindow.Stub: ViewRootImpl.W() ,APP侧的凭证 创建 ViewRootImpl时自动创建
public int addWindow(Session session, IWindow client, int seq,
            LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame,
            Rect outContentInsets, Rect outStableInsets,
            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,
            InsetsState outInsetsState, InsetsSourceControl[] outActiveControls,
            int requestUserId) {
    WindowState parentWindow = null;
	...
    synchronized (mGlobalLock) {
        ...
        if (mWindowMap.containsKey(client.asBinder())) {
            ProtoLog.w(WM_ERROR, "Window %s is already added", client);
            return WindowManagerGlobal.ADD_DUPLICATE_ADD;
        }
        ...
        WindowToken token = displayContent.getWindowToken(
                hasParent ? parentWindow.mAttrs.token : attrs.token);
        if (token == null) {
            if (!unprivilegedAppCanCreateTokenWith(parentWindow, callingUid, type,
                    rootType, attrs.token, attrs.packageName)) {
                return WindowManagerGlobal.ADD_BAD_APP_TOKEN;
            }
            if (hasParent) {
                // Use existing parent window token for child windows.
                token = parentWindow.mToken;
            } else {
                final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();
                //创建 token
                // dc.addWindowToken(token, this); 将window Token添加到 displayContent window树中
                token = new WindowToken(this, binder, type, false, displayContent,
                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);
            }
        }
        ...
        final WindowState win = new WindowState(this, session, client, token, parentWindow,
                appOp[0], seq, attrs, viewVisibility, session.mUid, userId,
                session.mCanAddInternalSystemWindow);
        ...
        win.attach();
        //添加到map集合中
        mWindowMap.put(client.asBinder(), win);
        ...
        //将 WindowState 添加到 WindowToken 下
        win.mToken.addWindow(win);
        ...
    }
}
```

## relayoutWindow

调用栈 应用层 ViewRootImpl.performTraversals ->Session.relayout()-> WMS.relayoutWindow()

> `应用进程`\
> ![fee480a0e26e48010fbb61a07d786455.png](/resources/79edd35cfad54abba8810e5b365b5cee.png)
> `system_process` wms\
> ![e8257e65a82d8a34e7085f25d2a788f0.png](/resources/2b1a687e1f7848f588b29edcd347dd4d.png)

```java
//ViewRootImpl.java
private void performTraversals() {
	// 请求wms relayout, 填充一些参数,surfaceControl ,surface...
	relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
	...
	performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
	
	if (lp.horizontalWeight > 0.0f) {
	    width += (int) ((mWidth - width) * lp.horizontalWeight);
	    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
	            MeasureSpec.EXACTLY);
	    measureAgain = true;
	}
	if (lp.verticalWeight > 0.0f) {
	    height += (int) ((mHeight - height) * lp.verticalWeight);
	    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,
	            MeasureSpec.EXACTLY);
	    measureAgain = true;
	}
	
	if (measureAgain) {
	    if (DEBUG_LAYOUT) Log.v(mTag,
	            "And hey let's measure once more: width=" + width
	            + " height=" + height);
	    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
	}
	...
	performLayout(lp, mWidth, mHeight);
	...
	performDraw();
	...
}


//WindowSession.aild
// 可以看到: 主要是客户端请求WMS 拿到一些数据(out标识)
int relayout(IWindow window, int seq, in WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility,
            int flags, long frameNumber, out Rect outFrame,
            out Rect outContentInsets, out Rect outVisibleInsets, out Rect outStableInsets,
            out Rect outBackdropFrame,
            out DisplayCutout.ParcelableWrapper displayCutout,
            out MergedConfiguration outMergedConfiguration, out SurfaceControl outSurfaceControl,
            out InsetsState insetsState, out InsetsSourceControl[] activeControls,
            out Point outSurfaceSize, out SurfaceControl outBlastSurfaceControl);

public int relayoutWindow(Session session, IWindow client, int seq, LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility, int flags,
            long frameNumber, Rect outFrame, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outBackdropFrame,
            DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,
            SurfaceControl outSurfaceControl, InsetsState outInsetsState,
            InsetsSourceControl[] outActiveControls, Point outSurfaceSize,
            SurfaceControl outBLASTSurfaceControl) {
	...
	synchronized (mGlobalLock) {
		//key:client 查询 mWindowMap 集合, 之前setView 时已经添加过了
		final WindowState win = windowForClientLocked(session, client, false);
        if (win == null) {
            return 0;
        }
		...
		final boolean shouldRelayout = viewVisibility == View.VISIBLE &&
                    (win.mActivityRecord == null || win.mAttrs.type == TYPE_APPLICATION_STARTING
                            || win.mActivityRecord.isClientVisible());
		...
		// We may be deferring layout passes at the moment, but since the client is interested
        // in the new out values right now we need to force a layout.
		// 遍历 window 树, 显示区域 限制
		mWindowPlacerLocked.performSurfacePlacement(true /* force */);
		...
		if (shouldRelayout) {
			try {
					//创建 WindowSurfaceController
					// resetDrawState() : mDrawState = DRAW_PENDING;
                    result = createSurfaceControl(outSurfaceControl, outBLASTSurfaceControl,
                            result, win, winAnimator);
                } catch (Exception e) {
                    displayContent.getInputMonitor().updateInputWindowsLw(true /*force*/);

                    ProtoLog.w(WM_ERROR,
                            "Exception thrown when creating surface for client %s (%s). %s",
                            client, win.mAttrs.getTitle(), e);
                    Binder.restoreCallingIdentity(origId);
                    return 0;
                }
		}
		...
	}
}
```

## finishDrawingWindow

调用栈(开启硬件加速,RenderThread) : mThreadedRenderer.setFrameCompleteCallback ->  mWindowSession.finishDrawing -> WMS.finishDrawingWindow()

> `应用进程`\
> ![5b8368e5299ecb6891f220e89eec6995.png](/resources/c04594f85fea47e0a111b6ff34de2d8c.png)
> `system_process` wms\
> ![83c515743141d42f547b6e1151697ba4.png](/resources/8cc70949cbb74ab48a319878e17bb651.png)

```java
void finishDrawingWindow(Session session, IWindow client,
        @Nullable SurfaceControl.Transaction postDrawTransaction) {
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (mGlobalLock) {
            WindowState win = windowForClientLocked(session, client, false);
            ProtoLog.d(WM_DEBUG_ADD_REMOVE, "finishDrawingWindow: %s mDrawState=%s",
                    win, (win != null ? win.mWinAnimator.drawStateToString() : "null"));
			// finishDrawing -> mWinAnimator.finishDrawingLocked -> mDrawState = COMMIT_DRAW_PENDING;
			// renturn true
            if (win != null && win.finishDrawing(postDrawTransaction)) {
                if ((win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                    win.getDisplayContent().pendingLayoutChanges |=
                            WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                }
                win.setDisplayLayoutNeeded();
				// WindowSurfacePlacer.requestTraversal
                mWindowPlacerLocked.requestTraversal();
            }
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}

//WindowSurfacePlacer.java
void requestTraversal() {
    if (mTraversalScheduled) {
        return;
    }

    // Set as scheduled even the request will be deferred because mDeferredRequests is also
    // increased, then the end of deferring will perform the request.
    mTraversalScheduled = true;
    if (mDeferDepth > 0) {
        mDeferredRequests++;
        if (DEBUG) Slog.i(TAG, "Defer requestTraversal " + Debug.getCallers(3));
        return;
    }
	//-> ... forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */); ---> commitFinishDrawingLocked()-> mDrawState = READY_TO_SHOW;
	// performShowLocked() -> mWinAnimator.mDrawState = HAS_DRAWN;
    mService.mAnimationHandler.post(mPerformSurfacePlacement);
}
mService.mAnimationHandler.post(mPerformSurfacePlacement);
	--> WindowSurfacePlacer.performSurfacePlacement
		-->do  performSurfacePlacementLoop() while()
			--> mService.mRoot.performSurfacePlacement();// RootWindowContainer
				--> for dc.applySurfaceChangesTransaction()//DisplayContent
					--> forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */);
						--> commitFinishDrawingLocked 
```

## DrawState

> 应用层还未 绘制完成,并提交到wms

- NO\_SURFACE(0) : 初始状态
- DRAW\_PENDING(1): surface 已经创建,但是 还没有会绘制东西

> 应用交给 wms 处理

- COMMIT\_DRAW\_PENDING(2): APP绘制完成,wms收到了应用的请求
- READY\_TO\_SHOW(3): 等待所有窗口 准备好 ,即将绘制到SurfaceFinger
- HAS\_DRAWN(4):首次显示完成,已经显示了,已经绘制到SurfaceFinger
